package cs735_835.noc;

import net.jcip.annotations.ThreadSafe;
import org.apache.commons.lang3.NotImplementedException;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.List;
import java.util.Random;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Pattern;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * A message.  Messages are generated by cores and routed through routers and wires to other cores.
 * Each message has a source, a destination, an id, and 2 timestamps (send and receive times).
 * Instances of this class are thread-safe.
 */
@ThreadSafe
public class Message implements Comparable<Message> {
  int identity;
  volatile int timeScheduled, timeSent = -1, timeReceived = -1;
  int rowSource, colSource, rowDest, colDest;

  AtomicBoolean tracking;

  /**
   * The natural order of messages, which is increasing order of ids.
   */
  public int compareTo(Message m) {
    return identity - m.getId();
  }

  /**
   * Message equality.  Two messages are equal if the have the same id.
   */
  @Override
  public boolean equals(Object o) {
    return o.getClass() == Message.class && ((Message) o).getId() == this.getId();
  }

  /**
   * Hash code.  This is the message id.
   */
  @Override
  public int hashCode() {
    return identity;
  }

  /**
   * Builds a new message.  The message is not tracked.
   *
   * @param scheduledTime the time at which the message will be sent (i.e., generated by a core);
   *                      it must be positive
   * @param sourceRow     the row the message will originate from
   * @param sourceCol     the column the message will originate from
   * @param destRow       the destination row
   * @param destCol       the destination column
   * @param id            the message identity
   * @throws IllegalArgumentException if {@code scheduledTime} is not positive
   */
  public Message(int id, int scheduledTime, int sourceRow, int sourceCol, int destRow, int destCol) {
    if( scheduledTime < 0 )
      throw new IllegalArgumentException("scheduled time cannot be negative");
    tracking = new AtomicBoolean( false );
    identity = id;
    timeScheduled = scheduledTime;
    rowSource = sourceRow;
    colSource = sourceCol;
    rowDest = destRow;
    colDest = destCol;
  }

  /**
   * A string representation of the message.  It is built <em>exactly</em> as follows:
   * <pre>
   * msg &lt;id&gt; (never sent)
   * </pre>
   * or
   * <pre>
   * msg &lt;id&gt; sent by (&lt;source row&gt;, &lt;source col&gt;) at &lt;send time&gt; (never delivered)
   * </pre>
   * or
   * <pre>
   * msg &lt;id&gt; sent by (&lt;source row&gt;, &lt;source col&gt;) at &lt;send time&gt;, delivered to (&lt;dest row&gt;, &lt;dest col&gt;) at&lt;receive time&gt;
   * </pre>
   */
  @Override
  public String toString() {
    if( !hasBeenSent() )
      return "msg " + identity + " (never sent)";
    if( !hasBeenReceived() )
      return  "msg "+identity+" sent by ("+rowSource+", "+colSource+") "+"at "+timeSent+" (never delivered)";

    return  "msg " + identity + " sent by (" + rowSource + ", " + colSource + ") " + "at " + timeSent +
            ", delivered to ("+rowDest+", "+colDest+") at "+ timeReceived;
  }

  /**
   * Message source (row).
   */
  public int sourceRow() {
    return rowSource;
  }

  /**
   * Message source (col).
   */
  public int sourceCol() {
    return colSource;
  }

  /**
   * Message destination (row).
   */
  public int destRow() {
    return rowDest;
  }

  /**
   * Message destination (col).
   */
  public int destCol() {
    return colDest;
  }

  /**
   * Message identity.
   */
  public int getId() {
    return identity;
  }

  /**
   * Tracking status.
   * Simulators display information about tracked messages as they travel the network.
   */
  public boolean isTracked() {
      return tracking.get();
  }

  /**
   * Sets the tracking status.
   */
  public void setTracked(boolean set) {
    tracking.set( set );
  }

  /**
   * The time at which the message is scheduled to be sent.  This is the time when the message
   * should be generated by a core and injected into the core queue to be picked up by the router.
   * It is set at construction time and never changes.
   */
  public int getScheduledTime() {
    return timeScheduled;
  }

  /**
   * The time at which this message was sent (that is, when the {@code send} method was called).
   * It is -1 if the message has not been sent.  Once it is nonnegative, its value never changes.
   */
  public int getSendTime() {
    return timeSent;
  }

  /**
   * The time at which this message was received (that is, when the {@code receive} method was
   * called).  It is -1 if the message has not been received.  Once it is nonnegative, the value
   * never changes and is guaranteed to be larger or equal to {@code getSendTime()}.
   */
  public int getReceiveTime() {
    return timeReceived;
  }

  /**
   * Marks the message as being sent.  This method can only be called once.
   *
   * @param time the sending time, which must be positive
   * @throws IllegalStateException    if this message has already been sent
   * @throws IllegalArgumentException if {@code time} is not positive
   */
  public void send(int time) {
    synchronized ( this ) {
      if (hasBeenSent())
        throw new IllegalStateException( "Message has already been sent" );
      if (time < 0)
        throw new IllegalArgumentException( "Time cannot be negative" );
      timeSent = time;
    }
  }

  /**
   * Marks the message as being received.  This method can only be called once.
   *
   * @param time the reception time, which must be positive
   * @throws IllegalStateException if this message has already been received or was never sent
   * @throws IllegalArgumentException if {@code time} is not positive or comes before sending time
   */
  public void receive(int time) {
    synchronized ( this ) {
      if (!hasBeenSent())
        throw new IllegalStateException("Message was received without being sent");
      if (time < 0 || time < timeSent)
        throw new IllegalArgumentException("Invalid time received");
      timeReceived = time;
    }
  }

  /**
   * Whether this message has been received.
   */
  public boolean hasBeenReceived() {
    return timeReceived != -1;
  }

  /**
   * Whether this message has been sent.
   */
  public boolean hasBeenSent() {
    return timeSent != -1;
  }

  /**
   * Parses a URL into a list of messages.
   * The syntax of the source is one message per line, as follows:
   * <pre>
   * id (row_sender, col_sender) (row_receiver, col_receiver) send_time
   * </pre>
   * or
   * <pre>
   * id (row_sender, col_sender) (row_receiver, col_receiver) send_time *
   * </pre>
   * Times are positive integers.  Empty lines and whitespaces are ignored.  In the second form,
   * the message is marked as being "tracked" and information about it will be displayed as it is
   * being routed. Messages are listed in the order in which they appear in the source and are all
   * unsent and unreceived.
   */
  public static List<Message> readMessagesFromURL(URL url) throws java.io.IOException {
    var messages = new java.util.ArrayList<Message>(128);
    try (var in = new BufferedReader(new InputStreamReader(url.openStream(), UTF_8))) {
      String line;
      while ((line = in.readLine()) != null) {
        line = line.trim();
        if (line.isEmpty())
          continue;
        var match = MESSAGE_DATA.matcher(line.replaceAll("\\s+", ""));
        if (match.matches()) {
          int id = Integer.parseInt(match.group(1));
          int fromRow = Integer.parseInt(match.group(2));
          int fromCol = Integer.parseInt(match.group(3));
          int toRow = Integer.parseInt(match.group(4));
          int toCol = Integer.parseInt(match.group(5));
          int time = Integer.parseInt(match.group(6));
          boolean track = !match.group(7).isEmpty();
          var message = new Message(id, time, fromRow, fromCol, toRow, toCol);
          if (track)
            message.setTracked(true);
          messages.add(message);
        } else {
          throw new IllegalArgumentException("cannot parse: " + line);
        }
      }
    }
    return messages;
  }

  private static final Pattern MESSAGE_DATA = Pattern.compile(
      "(\\p{Digit}+)" +
      "\\((\\p{Digit}+),(\\p{Digit}+)\\)" +
      "\\((\\p{Digit}+),(\\p{Digit}+)\\)" +
      "(\\p{Digit}+)" +
      "(\\*?)"
  );

  /**
   * A utility method to generate messages with a uniform distribution.  The messages are printed on
   * {@code System.out} in non-decreasing order of their sending times.
   *
   * @param rate   the rate at which messages are generated (in messages per cycle)
   * @param count  the number of messages
   * @param seed   the seed used for random number generation
   * @param width  the width of the network; sources and destination will have a column between 0
   *               and {@code width - 1}
   * @param height the height of the network; sources and destination will have a row between 0
   *               and {@code height - 1}
   */
  public static void uniformRandomTraffic(long seed, int width, int height,
                                          double rate, int count) {
    var rand = new Random(seed);
    double d = 2 / rate;
    double time = 1;
    for (int i = 1; i <= count; i++) {
      time += rand.nextDouble() * d;
      System.out.printf("%10d (%3d,%3d) (%3d,%3d) %10.0f%n",
          i, rand.nextInt(height), rand.nextInt(width), rand.nextInt(height), rand.nextInt(width),
          time);
    }
  }

  /**
   * Command-line application to generate random lists of messages. It is called as:
   * <pre>Message &lt;width&gt; &lt;height&gt; &lt;rate&gt; &lt;count&gt;</pre>
   * It calls method {@code uniformRandomTraffic} with a seed equal to 735835
   *
   * @see #uniformRandomTraffic
   */
  public static void main(String[] args) {
    int width = Integer.parseInt(args[0]);
    int height = Integer.parseInt(args[1]);
    double rate = Double.parseDouble(args[2]);
    int count = Integer.parseInt(args[3]);
    uniformRandomTraffic(735835, width, height, rate, count);
  }
}
